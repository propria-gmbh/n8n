{
  "name": "Shopify Product Listing v.0.2",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -832,
        304
      ],
      "id": "5c7dd5b5-22c3-4be9-8262-fb4e432dcf55",
      "name": "When clicking \u2018Execute workflow\u2019"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4.1-mini",
          "mode": "list",
          "cachedResultName": "GPT-4.1-MINI"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a top-tier US e-commerce expert for fashion dropshipping on Shopify + Meta Ads with 10+ years of experience.\nAlways return ONLY a valid JSON object, no explanations or markdown.\nNever hallucinate materials, features, product types, or specs that do not exist.\n\nYou receive compact product data in aiInput.\n\n=====================================================\nTASK:\nUsing aiInput, generate NEW high-converting values for the US market:\n\n\"title\"\n\"handle\"\n\"body_html\"\n\"tags\"\n\"product_type\"\n\nDO NOT EDIT:\n- product options or variants\n- prices\n- vendor\n- images\n- any IDs\n\n=====================================================\nCRITICAL CONSTRAINTS (DO NOT BREAK):\n\n1. NEVER invent a different product.\n2. Product category MUST stay identical to input.\n   If input is footwear \u2192 output footwear.\n   If input is apparel \u2192 output apparel.\n   If input is a bag/accessory \u2192 output a bag/accessory.\n\n3. \"product_type\" must stay in the same category and close in meaning to input.\n   Use Title Case (e.g. \"Midi Dress\", not \"dress\").\n\n4. \"shopifyProductId\" MUST be copied exactly from aiInput.\n\n5. Use only real features/specs present in the input description.\n   Do NOT create materials, lining, padding, stitching, closures, heel height, etc. if not found.\n\n=====================================================\nINPUT DATA:\n{{ JSON.stringify($json.aiInput) }}\n\n=====================================================\nMARKET & STYLE RULES:\n\n- Market: United States\n- Language: US English\n- Currency: USD ($)\n\nIf input text is not in English \u2192 translate first, then optimize.\n\nGENDER:\nDetermine Women / Men / Unisex from product_type + description only.\n\nTONE:\nShort sentences. Skimmable. Native US consumer wording.\nNo emojis. No urgency. No storewide policies.\n\nBANNED NAMES:\nDo not use these names anywhere:\nCoco, Chanel, Celine, Elara, Zara, Ami, Brioni, Chlo\u00e9, Kenzo, Santoni, Tod, Vince, Zilli, Calvin.\n\n=====================================================\nTITLE RULES:\n\nDYNAMIC NAME REQUIREMENT (STRICT):\n- Use exactly this first name as the very first word: {{ $json.generatedName }}\n- Handle must match that name in lowercase, no spaces or special characters.\n\n- The VERY FIRST WORD must be a human first name:\n  \u2022 feminine for Women\u2019s products  \n  \u2022 masculine for Men\u2019s  \n  \u2022 gender-neutral for Unisex  \n\n- The chosen name must NOT appear in the input title.\n- Do NOT reuse any name/brand from the input.\n- After the first name, include:\n  \u2022 SAME product category/type as input  \n  \u2022 1\u20132 key benefits/features  \n\n- Use singular (e.g. \u201cmidi dress\u201d, \u201csweater\u201d, \u201chandbag\u201d).\n- Max ~80 characters.\n- No pricing, shipping, policies, emojis, or caps-lock (except abbreviations).\n\n=====================================================\nHANDLE RULES:\n- EXACTLY the first name from the title\n- lowercased\n- no spaces\n- no special characters\n\n=====================================================\nTAGS RULES:\nChoose EXACTLY ONE:\n\n\"damen\"\n\"herren\"\n\"unisex\"\n\n=====================================================\nDESCRIPTION STRUCTURE (STRICT, NO EXCEPTIONS)\n\nYou MUST follow this exact block order.\nYou MAY vary the allowed H3 variants, nothing else.\n\nAllowed H3 for FIRST section (choose ONE):\n- \"Why You\u2019ll Love It\"\n- \"What Makes It Special\"\n- \"Made for Your Moments\"\n\nAllowed H3 for SECOND section (choose ONE):\n- \"Details\"\n- \"The Fit & Feel\"\n- \"Design Highlights\"\n\nTHIRD section H3 (MANDATORY EXACT):\n- \"Key Benefits\"\n\nFINAL section:\n- CTA paragraph (strong tag)\n\nDo NOT add any other headings or paragraphs.\n\n=======================================\nTEMPLATE (STRICT)\n=======================================\n\n<h3>[H3 Variant #1]</h3>\n<p>[1 short emotional benefit line]</p>\n\n<h3>[H3 Variant #2]</h3>\n<p>[real details: feel, movement, fit, use-cases; no invented specs]</p>\n\n<h3>Key Benefits</h3>\n<p>\u2713 [Benefit 1]</p>\n<p>\u2713 [Benefit 2]</p>\n<p>\u2713 [Benefit 3]</p>\n<p>\u2713 [Benefit 4]</p>\n\n<p><strong>[Short CTA, e.g. \u201cSelect your size and add to cart.\u201d]</strong></p>\n\n=====================================================\nPLACEHOLDERS (STRICT \u2014 INVISIBLE)\n\nAppend placeholders ONLY as HTML comments.\nThey must be invisible, placed on their own lines.\nThey must appear ONLY at the VERY END after the CTA paragraph.\n\nAllowed placeholder strings (EXACT):\n\n<!-- SIZE-CHART-PLACEHOLDER -->\n<!-- DIMENSIONS-PLACEHOLDER -->\n\nRULES:\n- If product is apparel \u2192 output ONLY:\n  <!-- SIZE-CHART-PLACEHOLDER -->\n\n- If product is non-apparel \u2192 output ONLY:\n  <!-- DIMENSIONS-PLACEHOLDER -->\n\nNever output both.\nNever mention size charts or dimensions visibly.\n\n=====================================================\nOUTPUT FORMAT\nReturn ONLY this JSON object:\n\n{\n  \"shopifyProductId\": {{ $json.aiInput[\"shopifyProductId\"] }},\n  \"title\": \"\",\n  \"handle\": \"\",\n  \"body_html\": \"\",\n  \"tags\": \"\",\n  \"product_type\": \"\"\n}\n\n"
            }
          ]
        },
        "jsonOutput": true,
        "options": {
          "maxTokens": 1000,
          "temperature": 0.6,
          "topP": 1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        -432,
        640
      ],
      "id": "7b941632-1244-49d4-ba96-62401d4028d1",
      "name": "Meta Message a model",
      "notesInFlow": true,
      "retryOnFail": true,
      "credentials": {
        "openAiApi": {
          "id": "B9IATT53OM1fRsAD",
          "name": "OpenAi account 2"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -832,
        640
      ],
      "id": "461c38a6-be37-4fdb-b090-f8fc32403844",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "3870c268-ba30-4dab-b3f8-540bc20cf687",
              "name": "targetLang",
              "value": "US English",
              "type": "string"
            },
            {
              "id": "b4c6ced2-d6dd-4804-8385-b911bfa8af54",
              "name": "vendorFixed",
              "value": "Charlie & Ted",
              "type": "string"
            },
            {
              "id": "30658db2-48a4-433e-b37f-751ad32444dd",
              "name": "profile",
              "value": "meta",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -656,
        304
      ],
      "id": "248b95d7-1bd4-4aec-927c-d78898f1d57c",
      "name": "Config"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "173O5ejvtbaN0LtfRtOprfkLs1rIEulB9DvT4sWKUkK8",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -464,
        304
      ],
      "id": "38af7080-e6ae-46cb-8649-cd3c99d56375",
      "name": "Download file",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "0heFHQl1fGUAqofO",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "xls",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -256,
        304
      ],
      "id": "109b253a-89de-43c2-a87e-a91ad5eec7ba",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "jsCode": "// This Function takes rows extracted from the OptionMap file\n// and builds two dictionaries:\n//\n// 1) canonicalByRaw: raw_string (any language) \u2192 Canonical key\n// 2) localesByCanonical: Canonical key \u2192 translations in all languages\n//\n// This allows us to:\n// - Normalize ANY color/option string into a canonical form\n// - Then output it in ANY target language dynamically (via targetLang)\n\nconst rows = $input.all().map(i => i.json);\n\nconst canonicalByRaw = {};\nconst localesByCanonical = {};\n\nconst langColumns = [\n  \"US English\",\n  \"UK English\",\n  \"Italian\",\n  \"French\",\n  \"German\",\n  \"Swedish\",\n  \"Danish\",\n];\n\nfor (const row of rows) {\n  const canonical = (row[\"Canonical\"] || \"\").trim();\n  const type = (row[\"Type\"] || \"\").trim().toLowerCase();\n\n  if (!canonical || !type) continue;\n\n  // Build the locales structure\n  localesByCanonical[canonical] = {};\n\n  for (const col of langColumns) {\n    const val = (row[col] || \"\").trim();\n    localesByCanonical[canonical][col] = val;\n  }\n\n  // Reverse index: ANY raw value \u2192 canonical\n  for (const col of langColumns) {\n    const rawVal = (row[col] || \"\").trim();\n    if (!rawVal) continue;\n\n    canonicalByRaw[rawVal.toLowerCase()] = canonical;\n  }\n}\n\nreturn [\n  {\n    json: {\n      canonicalByRaw,\n      localesByCanonical,\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -16,
        304
      ],
      "id": "37fb621e-5968-47a0-b0c5-cea83ec76133",
      "name": "Build Maps"
    },
    {
      "parameters": {
        "jsCode": "// Build Option Map (robust)\n// Mode: Run Once for All Items\n\nconst rows = $input.all().map(i => i.json);\n\n// 0) \u0415\u0441\u043b\u0438 \u043d\u0430 \u0432\u0445\u043e\u0434 \u0443\u0436\u0435 \u043f\u0440\u0438\u0448\u043b\u0430 \u0433\u043e\u0442\u043e\u0432\u0430\u044f optionMap \u2014 \u043f\u0440\u043e\u0441\u0442\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u043a\u0430\u043a \u0435\u0441\u0442\u044c\nif (\n  rows.length === 1 &&\n  rows[0] &&\n  rows[0].canonicalByRaw &&\n  rows[0].localesByCanonical\n) {\n  return [{ json: rows[0] }];\n}\n\n// helper: \u043d\u0430\u0439\u0442\u0438 \u043a\u043e\u043b\u043e\u043d\u043a\u0443 \u043f\u043e regex (case-insensitive)\nfunction findCol(obj, regexList) {\n  const keys = Object.keys(obj || {});\n  for (const rx of regexList) {\n    const k = keys.find(x => rx.test(x));\n    if (k) return k;\n  }\n  return null;\n}\n\nconst canonicalByRaw = {};\nconst localesByCanonical = {};\n\n// \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u044b \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0439 \u043a\u043e\u043b\u043e\u043d\u043e\u043a\nconst canonicalRegex = [/^canonical$/i, /canonical/i, /kanon/i];\nconst typeRegex      = [/^type$/i, /type/i, /gruppe/i, /kategorie/i];\n\n// \u044f\u0437\u044b\u043a\u043e\u0432\u044b\u0435 \u043a\u043e\u043b\u043e\u043d\u043a\u0438 \u2014 \u0438\u0449\u0435\u043c \u043f\u043e \u0438\u0437\u0432\u0435\u0441\u0442\u043d\u044b\u043c \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f\u043c, \u043d\u043e \u0442\u043e\u0436\u0435 case-insensitive\nconst langColumns = [\n  \"US English\",\n  \"UK English\",\n  \"Italian\",\n  \"French\",\n  \"German\",\n  \"Swedish\",\n  \"Danish\",\n];\n\n// 1) \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0440\u0435\u0430\u043b\u044c\u043d\u044b\u0435 \u0438\u043c\u0435\u043d\u0430 \u043a\u043e\u043b\u043e\u043d\u043e\u043a \u043f\u043e \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435\nconst sample = rows[0] || {};\nconst canonicalCol = findCol(sample, canonicalRegex);\nconst typeCol = findCol(sample, typeRegex);\n\n// \u0435\u0441\u043b\u0438 \u043d\u0435 \u043d\u0430\u0448\u043b\u0438 \u2014 \u0432\u0435\u0440\u043d\u0451\u043c \u043f\u0443\u0441\u0442\u044b\u0435 \u043a\u0430\u0440\u0442\u044b, \u043d\u043e \u0441 \u043f\u043e\u043d\u044f\u0442\u043d\u043e\u0439 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\nif (!canonicalCol || !typeCol) {\n  return [{\n    json: {\n      canonicalByRaw: {},\n      localesByCanonical: {},\n      error: true,\n      message: `Columns not found. canonicalCol=${canonicalCol}, typeCol=${typeCol}`,\n      sampleKeys: Object.keys(sample),\n    }\n  }];\n}\n\nfor (const row of rows) {\n  const canonical = (row[canonicalCol] || \"\").toString().trim();\n  const type = (row[typeCol] || \"\").toString().trim().toLowerCase();\n  if (!canonical || !type) continue;\n\n  if (!localesByCanonical[canonical]) {\n    localesByCanonical[canonical] = { type };\n  }\n\n  for (const col of langColumns) {\n    // \u0438\u0449\u0435\u043c \u043a\u043e\u043b\u043e\u043d\u043a\u0443 \u044f\u0437\u044b\u043a\u0430 \u0442\u043e\u0436\u0435 \u0431\u0435\u0437 \u0443\u0447\u0451\u0442\u0430 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\n    const realLangCol =\n      Object.keys(row).find(k => k.toLowerCase() === col.toLowerCase()) || col;\n\n    const val = (row[realLangCol] || \"\").toString().trim();\n    localesByCanonical[canonical][col] = val;\n\n    if (val) {\n      canonicalByRaw[val.toLowerCase()] = canonical;\n    }\n  }\n}\n\nreturn [{\n  json: {\n    canonicalByRaw,\n    localesByCanonical,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        304
      ],
      "id": "d13b3b03-18c0-4afc-81b2-feaa49d6ccaf",
      "name": "Build Option Maps"
    },
    {
      "parameters": {
        "authentication": "accessToken",
        "resource": "product",
        "operation": "getAll",
        "additionalFields": {
          "collection_id": "664621351251"
        }
      },
      "type": "n8n-nodes-base.shopify",
      "typeVersion": 1,
      "position": [
        432,
        304
      ],
      "id": "b94a2a3e-f62f-43f1-9fae-1b8865610769",
      "name": "Get many products",
      "alwaysOutputData": true,
      "executeOnce": true,
      "credentials": {
        "shopifyAccessTokenApi": {
          "id": "dWJgimry1w55uTT3",
          "name": "Shopify Access Token account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Code node: Normalize Options to Canonical\n// Mode: Run Once for Each Item\n\nconst j = $json ?? {};\nconst raw = j.raw ?? {};\n\nconst toObj = (v) => (v && typeof v === \"object\" && !Array.isArray(v)) ? v : {};\nconst toArr = (v) => Array.isArray(v) ? v : [];\n\nconst canonical = toObj(j.canonical);\nconst optionMap = toObj(j.optionMap);\n\n// --- helpers ---\nconst cleanName = (s) => (s ?? \"\").toString().trim();\nconst cleanVal  = (s) => (s ?? \"\").toString().trim();\n\nconst isRealValue = (v) => {\n  const x = cleanVal(v);\n  if (!x) return false;\n  if (/^default title$/i.test(x)) return false;\n  return true;\n};\n\n// 1) Get raw options, if any\nlet rawOptions = toArr(raw.options)\n  .map(o => ({\n    name: cleanName(o?.name),\n    position: Number(o?.position ?? 0),\n    values: toArr(o?.values).map(cleanVal).filter(isRealValue),\n    id: o?.id\n  }))\n  .filter(o => o.name);\n\n// 2) If raw.options missing or empty, infer from variants option1..option3\nconst rawVariants = toArr(raw.variants);\n\nif (rawOptions.length === 0 && rawVariants.length > 0) {\n  // infer option count by scanning variants.option1..3 presence\n  const inferred = [];\n  for (let i = 1; i <= 3; i++) {\n    const key = `option${i}`;\n    const vals = rawVariants\n      .map(v => v?.[key])\n      .map(cleanVal)\n      .filter(isRealValue);\n\n    if (vals.length) {\n      inferred.push({\n        name: `Option ${i}`,\n        position: i,\n        values: [...new Set(vals)]\n      });\n    }\n  }\n  rawOptions = inferred;\n}\n\n// 3) Canonicalize option names minimally (keep raw as canonical unless you later remap)\n// You can plug your own Canonicalize Options rules later.\nconst canonicalOptions = rawOptions\n  .sort((a,b)=>a.position-b.position)\n  .map((o, idx) => {\n    const canonName = o.name; // Phase 1: 1:1\n    if (!optionMap[canonName]) optionMap[canonName] = o.name;\n\n    return {\n      name: canonName,\n      position: idx + 1,\n      values: o.values\n    };\n  });\n\n// 4) Rebuild canonical variants with normalized option objects\nconst canonVariants = rawVariants.map(v => {\n  const optionValues = [];\n  const optionsObj = {};\n\n  for (let i = 0; i < canonicalOptions.length; i++) {\n    const pos = i + 1;\n    const rawOptName = rawOptions[i]?.name;\n    const canonName  = canonicalOptions[i].name;\n\n    const val = cleanVal(v?.[`option${pos}`]);\n\n    // accept empty but don't add junk\n    if (isRealValue(val)) {\n      optionValues.push(val);\n      optionsObj[canonName] = val;\n    }\n  }\n\n  return {\n    id: v?.id,\n    sku: v?.sku ?? null,\n    price: v?.price ?? null,\n    compare_at_price: v?.compare_at_price ?? null,\n    inventory_quantity: v?.inventory_quantity ?? null,\n    options: optionsObj,\n    optionValues\n  };\n});\n\n// 5) Write back\ncanonical.options  = canonicalOptions;\ncanonical.variants = canonVariants;\n\n// Also store a quick lookup set for later steps\ncanonical.optionNames = canonicalOptions.map(o => o.name);\n\nreturn {\n  json: {\n    ...j,\n    canonical,\n    optionMap\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        816,
        304
      ],
      "id": "fecbfcff-d1aa-4d67-8b30-97c393eddb9e",
      "name": "Normalize Options to Canonical"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Code node: Init Layers\n// Mode: Run Once for Each Item\n\nconst j = $json ?? {};\n\n// 1) Resolve raw product source safely\n// Priority: explicit raw -> explicit product -> full json\nconst rawSource =\n  (j.raw && typeof j.raw === \"object\")  ? j.raw :\n  (j.product && typeof j.product === \"object\") ? j.product :\n  j;\n\n// 2) Merge/normalize layers from any nesting level\nconst canonical = (j.canonical ?? rawSource.canonical ?? {});\nconst ai        = (j.ai ?? rawSource.ai ?? {});\nconst localized = (j.localized ?? rawSource.localized ?? {});\nconst patch     = (j.patch ?? rawSource.patch ?? {});\n\n// Ensure layers are plain objects (not arrays/null/primitives)\nconst toObj = (v) => (v && typeof v === \"object\" && !Array.isArray(v)) ? v : {};\nconst safeCanonical = toObj(canonical);\nconst safeAi        = toObj(ai);\nconst safeLocalized = toObj(localized);\nconst safePatch     = toObj(patch);\n\n// 3) Carry optionMap/config from anywhere, keep objects\nconst optionMap = toObj(j.optionMap ?? rawSource.optionMap ?? {});\nconst config    = toObj(j.config    ?? rawSource.config    ?? {});\n\n// 4) Detect sourceType reliably\n// If Shopify product: has admin_graphql_api_id OR variants array typical of Shopify payload\nconst isShopify =\n  !!rawSource.admin_graphql_api_id ||\n  (Array.isArray(rawSource.variants) && rawSource.variants.length >= 0);\n\nconst sourceType = j.sourceType ?? (isShopify ? \"shopify\" : \"competitor\");\n\n// 5) Return layered structure\nreturn {\n  json: {\n    raw: rawSource,\n    canonical: safeCanonical,\n    ai: safeAi,\n    localized: safeLocalized,\n    patch: safePatch,\n    optionMap,\n    config,\n    sourceType,\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        304
      ],
      "id": "4d5d5257-61b6-4048-bcac-09a7097c7381",
      "name": "Init Layers"
    },
    {
      "parameters": {
        "jsCode": "// Build Patch: sanitize placeholders + wrap for Shopify REST\nconst items = $input.all();\n\nfunction stripPlaceholders(html, mode) {\n  if (!html) return \"\";\n  let out = html;\n\n  if (mode === \"size\") {\n    out = out.replace(/<!--\\s*SIZE-CHART-PLACEHOLDER\\s*-->\\s*/gi, \"\");\n  }\n  if (mode === \"dims\") {\n    out = out.replace(/<!--\\s*DIMENSIONS-PLACEHOLDER\\s*-->\\s*/gi, \"\");\n  }\n  return out.trim();\n}\n\nfor (const item of items) {\n  const j = item.json;\n\n  if (j.patch?.skip) continue;\n  if (!j.patch?.product) {\n    j.patch = { skip: true, reason: \"No patch.product to sanitize\" };\n    continue;\n  }\n\n  const raw = j.raw || {};\n  const ai  = j.ai || {};\n  const loc = j.localized || {};\n  const minimal = j.patch.product;\n\n  // \u2705 Robust apparel detector: raw -> localized -> ai\n  const pt =\n    (raw.product_type || raw.productType ||\n     loc.product_type || ai.product_type || \"\")\n      .toString().toLowerCase();\n\n  const apparel =\n    j.canonical?.isApparel === true ||\n    /(dress|shirt|tee|hoodie|pants|jeans|skirt|jacket|coat|sweater|top|blouse|apparel|clothing)/i.test(pt);\n\n  let body = minimal.body_html || \"\";\n\n  if (apparel) {\n    body = stripPlaceholders(body, \"dims\");  // keep SIZE, remove DIMS\n  } else {\n    body = stripPlaceholders(body, \"size\");  // keep DIMS, remove SIZE\n  }\n\n  minimal.body_html = body;\n\n  // final REST envelope for Shopify PUT /products/{id}.json\n  j.patch.product = {\n    product: {\n      id: minimal.id,\n      title: minimal.title,\n      handle: minimal.handle,\n      body_html: minimal.body_html,\n      tags: minimal.tags,\n      product_type: minimal.product_type,\n    }\n  };\n\n  // safety: no options/variants in patch\n  delete j.patch.product.product.options;\n  delete j.patch.product.product.variants;\n}\n\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        304,
        640
      ],
      "id": "07b4e58c-5c4b-410e-8eef-639a495cf167",
      "name": "Build Patch"
    },
    {
      "parameters": {
        "jsCode": "// Map AI -> localized (+ patch draft) + productId\nconst items = $input.all();\n\nfor (const item of items) {\n  const j = item.json;\n\n  j.localized = j.localized || {};\n  j.patch = j.patch || {};\n\n  // If validator said skip OR no ai => skip downstream\n  if (j.aiValidation?.ok === false || j.patch.skip || !j.ai || !j.ai.title) {\n    j.patch = { skip: true, reason: j.patch.reason || \"AI validation failed\" };\n    continue;\n  }\n\n  const ai = j.ai;\n  const raw = j.raw || {};\n\n  // reliable productId for URL\n  const productId = raw.id || ai.shopifyProductId || ai.id;\n  if (!productId) {\n    j.patch = { skip: true, reason: \"No productId found in raw/ai\" };\n    continue;\n  }\n  j.productId = productId;\n\n  // localized.product \u2014 store final localized values\n  j.localized = {\n    shopifyProductId: productId,\n    title: ai.title,\n    handle: ai.handle,\n    body_html: ai.body_html,\n    tags: ai.tags,\n    product_type: ai.product_type,\n  };\n\n  // patch.product \u2014 MINIMAL fields only (no envelope yet)\n  j.patch = {\n    product: {\n      id: productId,\n      title: ai.title,\n      handle: ai.handle,\n      body_html: ai.body_html,\n      tags: ai.tags,\n      product_type: ai.product_type,\n    }\n  };\n}\n\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        640
      ],
      "id": "ccbd7f69-ded9-416e-9660-55a20cf18a2a",
      "name": "Map AI"
    },
    {
      "parameters": {
        "jsCode": "// Code node before AI: Build aiInput\nconst r = $json.raw;\nconst c = $json.canonical;\n\nconst aiInput = {\n  shopifyProductId: r.id,   // <-- \u0434\u043e\u0431\u0430\u0432\u0438\u043b\u0438\n  id: r.id,                 // \u043c\u043e\u0436\u043d\u043e \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0434\u043b\u044f \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u0438\u043c\u043e\u0441\u0442\u0438\n  title: r.title,\n  handle: r.handle,\n  vendor: r.vendor,\n  product_type: r.product_type,\n  tags: r.tags,\n  body_html: r.body_html,\n  options: (r.options || []).map(o => ({ name: o.name, values: o.values })),\n  images: (r.images || []).slice(0, 2).map(i => ({ src: i.src, alt: i.alt })),\n  canonical: {\n    options: c.options,\n    optionNames: c.optionNames\n  }\n};\n\nreturn {\n  json: {\n    ...$json,\n    aiInput\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -656,
        640
      ],
      "id": "eb80208e-2b98-480a-8f07-7a7b6004f5b1",
      "name": "aiInput"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nfor (const item of items) {\n  const j = item.json;\n\n  const raw = j.raw || {};\n  const ai  = j.ai  || {};\n  const loc = j.localized || {};\n\n  // --- \u0433\u0434\u0435 \u043b\u0435\u0436\u0438\u0442 \u0440\u0435\u0430\u043b\u044c\u043d\u044b\u0439 AI output ---\n  // \u0412 \u0442\u0432\u043e\u0451\u043c \u0444\u043b\u043e\u0443 AI-\u043d\u043e\u0434\u0430 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442:\n  // item.json.message.content\n  // MapAI \u043f\u043e\u0442\u043e\u043c \u043a\u043b\u0430\u0434\u0451\u0442 \u044d\u0442\u043e \u0432 j.ai \u0438 j.localized\n  //\n  // \u041f\u043e\u044d\u0442\u043e\u043c\u0443 \u0442\u0443\u0442 \u0431\u0435\u0440\u0435\u043c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e \u0443\u0441\u0442\u043e\u0439\u0447\u0438\u0432\u043e:\n  const aiOut =\n    loc.shopifyProductId ? loc :\n    ai.shopifyProductId  ? ai  :\n    (j.message && j.message.content) ? j.message.content :\n    null;\n\n  j.aiValidation = { ok: true, errors: [], warnings: [] };\n\n  if (!aiOut || typeof aiOut !== \"object\") {\n    j.aiValidation.ok = false;\n    j.aiValidation.errors.push(\"AI output missing or not an object\");\n    j.patch = { skip: true, reason: \"AI validation failed\" };\n    continue;\n  }\n\n  // --- productId \u0438\u0437 \u0432\u0445\u043e\u0434\u0430 (\u0438\u0437 aiInput) ---\n  const inputId =\n    (j.aiInput && (j.aiInput.shopifyProductId || j.aiInput.id)) ||\n    raw.id ||\n    j.shopifyProductId;\n\n  if (inputId && aiOut.shopifyProductId && Number(aiOut.shopifyProductId) !== Number(inputId)) {\n    j.aiValidation.ok = false;\n    j.aiValidation.errors.push(\n      `shopifyProductId mismatch (ai=${aiOut.shopifyProductId}, input=${inputId})`\n    );\n  }\n\n  // --- \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 body_html \u043f\u043e \u0448\u0430\u0431\u043b\u043e\u043d\u0443 ---\n  const body = (aiOut.body_html || \"\").toString();\n\n  const hasKeyBenefits = body.includes(\"<h3>Key Benefits</h3>\");\n  if (!hasKeyBenefits) {\n    j.aiValidation.ok = false;\n    j.aiValidation.errors.push(\"body_html missing heading: <h3>Key Benefits</h3>\");\n  }\n\n  // \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u0432\u0442\u043e\u0440\u043e\u0439 H3 \u043e\u0434\u0438\u043d \u0438\u0437 \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0445\n  const secondH3Allowed = [\n    \"<h3>Details</h3>\",\n    \"<h3>The Fit & Feel</h3>\",\n    \"<h3>Design Highlights</h3>\"\n  ].some(h => body.includes(h));\n\n  if (!secondH3Allowed) {\n    j.aiValidation.ok = false;\n    j.aiValidation.errors.push(\"body_html missing valid second heading\");\n  }\n\n  // --- Title & handle guardrails ---\n  const requiredName = (j.generatedName || '').toString().trim();\n  if (requiredName) {\n    const title = (aiOut.title || '').toString().trim();\n    const startsWithName = title.toLowerCase().startsWith(requiredName.toLowerCase());\n    if (!startsWithName) {\n      j.aiValidation.ok = false;\n      j.aiValidation.errors.push(`title must start with \"${requiredName}\"`);\n    }\n\n    const expectedHandle = requiredName\n      .toLowerCase()\n      .replace(/[^a-z0-9]/g, '');\n    const handle = (aiOut.handle || '').toString().trim();\n    if (handle !== expectedHandle) {\n      j.aiValidation.ok = false;\n      j.aiValidation.errors.push(`handle must equal lowercase first name (${expectedHandle})`);\n    }\n  }\n\n  // --- placeholder rules ---\n  const hasSize = body.includes(\"<!-- SIZE-CHART-PLACEHOLDER -->\");\n  const hasDim  = body.includes(\"<!-- DIMENSIONS-PLACEHOLDER -->\");\n\n  // \u0437\u0434\u0435\u0441\u044c \u043c\u044f\u0433\u043a\u0430\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430: \u043d\u0435 \u0432\u0430\u043b\u0438\u043c, \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0430\u0435\u043c\n  if (!hasSize && !hasDim) {\n    j.aiValidation.warnings.push(\"No placeholder marker included\");\n  }\n\n  // \u0435\u0441\u043b\u0438 \u043d\u0435 \u043e\u043a \u2014 \u0441\u0442\u0430\u0432\u0438\u043c skip\n  if (!j.aiValidation.ok) {\n    j.patch = { skip: true, reason: \"AI validation failed\" };\n  } else {\n    // \u043a\u043b\u0430\u0434\u0435\u043c \u043d\u043e\u0440\u043c\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0439 aiOut \u0432 j.ai \u0434\u043b\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u043d\u043e\u0434\n    j.ai = aiOut;\n  }\n}\n\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -96,
        640
      ],
      "id": "34408801-f535-46bb-827c-39ba836b5950",
      "name": "Validate AI Output"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "760bd542-c2ca-46b6-abfe-448b6da3c41a",
              "leftValue": "={{ $json.patch?.skip !== true }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        480,
        640
      ],
      "id": "e6a4d98a-ffb8-4488-8753-3b6ea27256b0",
      "name": "If"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ \"https://dca4de.myshopify.com/admin/api/2025-10/products/\" + $json[\"productId\"] + \".json\" }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "shopifyAccessTokenApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{$json.patch.product}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        704,
        640
      ],
      "id": "b93342cf-765d-4831-866f-49909c650d5a",
      "name": "HTTP Request",
      "credentials": {
        "shopifyAccessTokenApi": {
          "id": "dWJgimry1w55uTT3",
          "name": "Shopify Access Token account"
        }
      }
    },
    {
      "parameters": {
        "operation": "xls",
        "options": {
          "sheetName": "Names"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -256,
        144
      ],
      "id": "2c3ebaa1-7f89-4a6d-9afd-b6c995a97b2d",
      "name": "Extract Names"
    },
    {
      "parameters": {
        "jsCode": "// Build name pools from Names sheet\nconst rows = $input.all().map(item => item.json || {});\nconst pools = {\n  women: [],\n  men: [],\n  unisex: [],\n};\n\nconst pushUnique = (bucket, value) => {\n  if (!value) return;\n  const exists = pools[bucket].some(n => n.toLowerCase() === value.toLowerCase());\n  if (!exists) pools[bucket].push(value);\n};\n\nfor (const row of rows) {\n  const name = (row.name || row.Name || '').toString().trim();\n  if (!name) continue;\n  const genderRaw = (row.gender || row.Gender || '').toString().trim().toLowerCase();\n  let bucket = 'unisex';\n  if (/men|male|herr|masc/.test(genderRaw)) bucket = 'men';\n  else if (/uni|all|neutral/.test(genderRaw)) bucket = 'unisex';\n  else if (/women|female|frau|damen/.test(genderRaw)) bucket = 'women';\n  else if (!genderRaw) bucket = 'unisex';\n  else bucket = 'women';\n  pushUnique(bucket, name);\n}\n\nconst resolveStaticData = () => {\n  if (typeof $getWorkflowStaticData === 'function') {\n    return $getWorkflowStaticData('global');\n  }\n  if (typeof getWorkflowStaticData === 'function') {\n    return getWorkflowStaticData('global');\n  }\n  if (typeof globalThis !== 'undefined') {\n    if (typeof globalThis.$getWorkflowStaticData === 'function') {\n      return globalThis.$getWorkflowStaticData('global');\n    }\n    if (typeof globalThis.getWorkflowStaticData === 'function') {\n      return globalThis.getWorkflowStaticData('global');\n    }\n  }\n  throw new Error('Workflow static data helpers unavailable in this Code node runtime.');\n};\nconst staticData = resolveStaticData();\nstaticData.namePools = pools;\nif (!Array.isArray(staticData.recentNameHistory)) {\n  staticData.recentNameHistory = [];\n}\n\nreturn [{ json: { namePools: pools } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -16,
        144
      ],
      "id": "e5a94f1c-8a8b-4f25-8c74-6a3f9fe13d51",
      "name": "Build Name Pools"
    },
    {
      "parameters": {
        "mode": "passThrough",
        "output": "input1"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        304,
        304
      ],
      "id": "9cd87014-7ac5-45b6-b3c1-86e4b74a40e0",
      "name": "Wait for Names"
    },
    {
      "parameters": {
        "jsCode": "// Assign a unique first name per product based on pools\nconst items = $input.all();\nconst resolveStaticData = () => {\n  if (typeof $getWorkflowStaticData === 'function') {\n    return $getWorkflowStaticData('global');\n  }\n  if (typeof getWorkflowStaticData === 'function') {\n    return getWorkflowStaticData('global');\n  }\n  if (typeof globalThis !== 'undefined') {\n    if (typeof globalThis.$getWorkflowStaticData === 'function') {\n      return globalThis.$getWorkflowStaticData('global');\n    }\n    if (typeof globalThis.getWorkflowStaticData === 'function') {\n      return globalThis.getWorkflowStaticData('global');\n    }\n  }\n  throw new Error('Workflow static data helpers unavailable in this Code node runtime.');\n};\nconst staticData = resolveStaticData();\nconst pools = staticData.namePools || {};\nlet history = Array.isArray(staticData.recentNameHistory) ? [...staticData.recentNameHistory] : [];\nconst maxHistory = 50;\n\nconst normalize = (str = '') => str.toString().trim();\nconst toKey = (str = '') => normalize(str).toLowerCase();\nlet recentSet = new Set(history.map(toKey));\n\nconst detectGender = (payload = {}) => {\n  const collect = [\n    payload.product_type,\n    payload.productType,\n    payload.title,\n    payload.tags,\n    payload.body_html,\n    payload.bodyHtml,\n  ].map(x => (x || '').toString().toLowerCase());\n  const blob = collect.join(' ');\n  if (/unisex|genderless|all gender|uni\b/.test(blob)) return 'unisex';\n  if (/(men's|mens|men\b|male|herr|herren)/.test(blob)) return 'men';\n  if (/(women's|womens|women|female|damen|frau)/.test(blob)) return 'women';\n  return 'women';\n};\n\nconst pickFromBuckets = (buckets) => {\n  for (const bucket of buckets) {\n    const list = pools[bucket] || [];\n    for (const candidate of list) {\n      if (!recentSet.has(toKey(candidate))) {\n        return candidate;\n      }\n    }\n  }\n  return null;\n};\n\nfor (const item of items) {\n  const j = item.json || {};\n  const raw = j.raw || {};\n  const gender = detectGender(raw);\n  const order = gender === 'men'\n    ? ['men', 'unisex', 'women']\n    : gender === 'unisex'\n      ? ['unisex', 'women', 'men']\n      : ['women', 'unisex', 'men'];\n\n  const selected = pickFromBuckets(order);\n\n  if (!selected) {\n    j.generatedName = null;\n    j.patch = { skip: true, reason: 'name_pool_exhausted' };\n    j.aiValidation = { ok: false, errors: ['Name pool exhausted'], warnings: [] };\n    continue;\n  }\n\n  j.generatedName = selected;\n  history = [selected, ...history.filter(n => toKey(n) !== toKey(selected))];\n  if (history.length > maxHistory) {\n    history = history.slice(0, maxHistory);\n  }\n  recentSet = new Set(history.map(toKey));\n}\n\nstaticData.recentNameHistory = history;\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -512,
        640
      ],
      "id": "deffacbc-ce56-4dff-9a3b-901da488bd87",
      "name": "Pick Unique Name"
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking \u2018Execute workflow\u2019": {
      "main": [
        [
          {
            "node": "Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Meta Message a model": {
      "main": [
        [
          {
            "node": "Validate AI Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [],
        [
          {
            "node": "Pick Unique Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Config": {
      "main": [
        [
          {
            "node": "Download file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download file": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract Names",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Build Maps",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Maps": {
      "main": [
        [
          {
            "node": "Build Option Maps",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Option Maps": {
      "main": [
        [
          {
            "node": "Wait for Names",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many products": {
      "main": [
        [
          {
            "node": "Init Layers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Options to Canonical": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init Layers": {
      "main": [
        [
          {
            "node": "Normalize Options to Canonical",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Patch": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map AI": {
      "main": [
        [
          {
            "node": "Build Patch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "aiInput": {
      "main": [
        [
          {
            "node": "Pick Unique Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate AI Output": {
      "main": [
        [
          {
            "node": "Map AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Names": {
      "main": [
        [
          {
            "node": "Build Name Pools",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Name Pools": {
      "main": [
        [
          {
            "node": "Wait for Names",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait for Names": {
      "main": [
        [
          {
            "node": "Get many products",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pick Unique Name": {
      "main": [
        [
          {
            "node": "Meta Message a model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "5a0d12db-1f5e-463e-bd20-906fff5df1f7",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "874b8b595b8c35c6ad0480eb2e6d2c9dcb3d2674b017cfcfab20dbd92e7f9969"
  },
  "id": "YqUMChMOluc1ktdD",
  "tags": []
}